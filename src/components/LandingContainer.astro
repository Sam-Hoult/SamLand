---


---

<div class="threejs-container">
  <div id="threejs-canvas">
    <div class="loading-spinner"></div>
  </div>
</div>

<script>
    // Update imports to use relative paths if needed
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
    import { GCodeLoader } from 'three/examples/jsm/loaders/GCodeLoader.js';
    import { FontLoader } from 'three/addons/loaders/FontLoader.js';
    import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

    let camera, scene, renderer;
    let modelsLoaded = 0;
    const totalModels = 2; // Updated to include text as a "model"

    init();
    render();

    function init() {
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.set(0, 20, 80);
        
        let textMesh;
        let gcodeMesh;  // Store reference to the gcode object

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        const loader = new GCodeLoader();
        loader.load('models/samland.gcode', function (object) {
            // Change the material color for all line segments
            object.children.forEach(child => {
                if (child.isLine) {
                    child.material = new THREE.LineBasicMaterial({ 
                        color: '#0ef85c',
                        opacity: 0.2,
                        transparent: true
                    });
                }
            });
            
            object.position.set(-155, -20, 150);
            gcodeMesh = object;  // Store reference
            scene.add(object);
            modelsLoaded++;
            checkAllModelsLoaded();
            render();
        });

        // Add text
        const fontLoader = new FontLoader();
        fontLoader.load('/fonts/helvetiker_bold.typeface.json', function (font) {
            const textGeometry = new TextGeometry('SAMLAND', {
                font: font,
                size: 10,
                depth: 2,
                curveSegments: 12,
                bevelEnabled: true,
                bevelThickness: 0.5,
                bevelSize: 0.3,
                bevelOffset: 0,
                bevelSegments: 5
            });

            // Center the geometry itself
            textGeometry.computeBoundingBox();
            textGeometry.center();

            const textMaterial = new THREE.MeshBasicMaterial({ 
                color: '#00ff00',
                wireframe: true 
            });
            textMesh = new THREE.Mesh(textGeometry, textMaterial);
            
            // Center the text
            textGeometry.computeBoundingBox();
            const centerOffset = -0.1 * (textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x);
            textMesh.position.x = centerOffset;
            textMesh.position.y = 17;
            textMesh.position.z = 0;

            scene.add(textMesh);
            modelsLoaded++;
            checkAllModelsLoaded();
            render();
        });

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        
        const canvas = document.getElementById('threejs-canvas');
        canvas.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.addEventListener('change', render);
        controls.minDistance = 10;
        controls.maxDistance = 200;
        controls.enableZoom = true;
        controls.enablePan = true;

        // Update mousemove event listener
        canvas.addEventListener('mousemove', (event) => {
            // Calculate normalized mouse position (-1 to 1)
            const mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            const mouseY = (event.clientY / window.innerHeight) * 2 - 1;

            // Apply subtle rotation to text if it exists
            if (textMesh) {
                textMesh.rotation.x = mouseY * 0.1;
                textMesh.rotation.y = mouseX * 0.1;
            }
            
            render();
        });

        window.addEventListener('resize', resize);
    }

    function checkAllModelsLoaded() {
        if (modelsLoaded === totalModels) {
            // Hide the loading spinner
            document.querySelector('.loading-spinner').style.display = 'none';
        }
    }

    function resize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        render();
    }

    function render() {
        renderer.render(scene, camera);
    }
</script>

<style>
  .threejs-container {
    background-color: rgb(var(--black));
  }
  #threejs-canvas {
    position: relative;  /* Add this to properly position the spinner */
    width: 100%;
    height: 100%;
    min-height: 50vh;
    overflow: hidden;
  }

  h1 {
    margin: 0;
    font-size: 1.5em;
    color: #444;
  }

  .loading-spinner {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 50px;
    height: 50px;
    border: 3px solid rgba(255, 255, 255, 0.3);
    border-radius: 50%;
    border-top-color: #fff;
    animation: spin 1s ease-in-out infinite;
  }

  @keyframes spin {
    to { transform: translate(-50%, -50%) rotate(360deg); }
  }

</style>
